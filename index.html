<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>AI Village ‚Äî Pixel Edition v3 (Mobile)</title>
<style>
  :root { --bg:#0d0f13; --fg:#e9f1ff; --muted:#9cb2cc; --panel:#141821; --panel-2:#1b2230; --accent:#7cc4ff; }
  html, body { margin:0; padding:0; height:100%; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial; overflow:hidden; -webkit-tap-highlight-color: transparent; }
  #game { position:fixed; inset:0; width:100vw; height:100vh; background:#0a0c10; image-rendering:pixelated; image-rendering:crisp-edges; touch-action:none; display:block; }
  .hud-top { position: fixed; left: 10px; right: 10px; top: 10px; display:flex; justify-content:space-between; align-items:center; gap:10px; pointer-events:none; }
  .pill { pointer-events:auto; background: rgba(20,24,33,0.9); border:1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 8px 10px; display:flex; gap:12px; align-items:center; box-shadow: 0 4px 18px rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
  .stat { font-weight:700; font-size:14px } .stat small { color: var(--muted); font-weight:600; margin-left:4px }
  .btn { pointer-events:auto; border:1px solid rgba(255,255,255,0.1); background: rgba(27,35,48,0.95); color:var(--fg); border-radius:10px; padding:8px 10px; font-weight:700; font-size:14px; }
  .btn:active { transform: translateY(1px) }
  .hud-bottom { position:fixed; left:10px; right:10px; bottom:10px; pointer-events:none; }
  .bar { pointer-events:auto; background: rgba(27,35,48,0.9); border:1px solid rgba(255,255,255,0.1); border-radius:14px; padding:10px; display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; }
  .chip { text-align:center; font-weight:700; font-size:13px; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); color:var(--fg); border-radius:10px; padding:8px 10px; user-select:none; }
  .chip[data-active="true"] { background: rgba(124,196,255,0.18); border-color: rgba(124,196,255,0.55); }
  .sheet { position:fixed; left:0; right:0; bottom:0; transform: translateY(100%); transition: transform .2s ease; background: var(--panel-2); border-top:1px solid rgba(255,255,255,0.08); border-radius: 16px 16px 0 0; padding: 12px 12px calc(env(safe-area-inset-bottom) + 12px); max-height: 65vh; overflow:auto; box-shadow: 0 -12px 30px rgba(0,0,0,0.5); }
  .sheet[data-open="true"] { transform: translateY(0) } .sheet h3 { margin: 6px 2px 10px; font-size: 16px; color: var(--muted); }
  .grid { display:grid; grid-template-columns: repeat(4, 1fr); gap:8px }
  .tile { text-align:center; font-size:12px; padding:10px; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); border-radius:10px; user-select:none; }
  .slider { appearance:none; width:100%; height:8px; border-radius:999px; background:#2b3544; outline:none; }
  .slider::-webkit-slider-thumb { appearance:none; width:22px; height:22px; border-radius:50%; background: var(--accent); border: 2px solid rgba(255,255,255,0.35); box-shadow: 0 2px 6px rgba(0,0,0,0.45); }
  .toast { position: fixed; left:50%; bottom:86px; transform: translateX(-50%) translateY(200%); transition: transform .25s ease; background: rgba(20,24,33,0.95); border:1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 10px 14px; pointer-events:none; font-weight:700; font-size:14px; }
  .toast[data-show="true"] { transform: translateX(-50%) translateY(0) }
  #help { position: fixed; left: 12px; right: 12px; top: 12px; background: rgba(20,24,33,0.95); border: 1px solid rgba(255,255,255,0.12); border-radius: 12px; padding: 12px; font-size: 14px; line-height: 1.4; box-shadow: 0 10px 30px rgba(0,0,0,0.6); display: none; }
  #help button { margin-top: 8px }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="hud-top">
  <div class="pill" id="stats">
    <div class="stat">üçû <span id="food">0</span><small>food</small></div>
    <div class="stat">ü™µ <span id="wood">0</span><small>wood</small></div>
    <div class="stat">ü™® <span id="stone">0</span><small>stone</small></div>
    <div class="stat">üë• <span id="pop">0</span><small>pop</small></div>
  </div>
  <div class="pill">
    <button class="btn" id="btnPause">‚è∏</button>
    <button class="btn" id="btnSpeed">1√ó</button>
    <button class="btn" id="btnSave">üíæ</button>
    <button class="btn" id="btnNew">üó∫Ô∏è New</button>
  </div>
</div>

<div class="hud-bottom">
  <div class="bar">
    <button class="chip" id="chipInspect">Inspect / Pan</button>
    <button class="chip" id="chipZones">Zones (paint)</button>
    <button class="chip" id="chipBuild">Build</button>
    <button class="chip" id="chipPrior">Priorities</button>
  </div>
</div>

<div class="sheet" id="sheetZones">
  <h3>Zones (pixel markers)</h3>
  <div class="grid">
    <div class="tile" data-zone="farm">üåæ Farm</div>
    <div class="tile" data-zone="cut">ü™ì Cut Trees</div>
    <div class="tile" data-zone="mine">‚õèÔ∏è Mine Stone</div>
    <div class="tile" data-zone="erase">üßπ Clear</div>
  </div>
  <h3>Brush Size</h3>
  <input type="range" min="1" max="6" value="2" class="slider" id="brushSize">
</div>

<div class="sheet" id="sheetBuild">
  <h3>Build</h3>
  <div class="grid">
    <div class="tile" data-build="hut">üèöÔ∏è Hut (10 wood)</div>
    <div class="tile" data-build="storage">üì¶ Storage (8 wood)</div>
    <div class="tile" data-build="farmplot">üå± Farm Plot (4 wood)</div>
    <div class="tile" data-build="well">üï≥Ô∏è Well (6 stone)</div>
  </div>
</div>

<div class="sheet" id="sheetPrior">
  <h3>Village Priorities</h3>
  <div style="display:flex; gap:10px">
    <div style="flex:1"><div style="font-weight:700;margin-bottom:4px">Food</div><input type="range" id="prioFood" class="slider" min="0" max="100" value="70"></div>
    <div style="flex:1"><div style="font-weight:700;margin-bottom:4px">Build</div><input type="range" id="prioBuild" class="slider" min="0" max="100" value="50"></div>
    <div style="flex:1"><div style="font-weight:700;margin-bottom:4px">Explore</div><input type="range" id="prioExplore" class="slider" min="0" max="100" value="30"></div>
  </div>
</div>

<div id="help">
  <div style="font-weight:700; margin-bottom:6px">Pixel Edition v3 ‚Äî Quickstart</div>
  - Pinch to <b>zoom</b>, drag with one finger to <b>pan</b> (in Inspect/Build/Priorities).<br/>
  - If you saw a blank screen previously, this build fixes camera scaling.<br/>
  <button class="btn" id="btnHelpClose">Got it</button>
</div>

<div class="toast" id="toast"></div>

<script>
(function(){
'use strict';

/* ==================== Constants & Types ==================== */
const TILE = 32, MAP_W = 96, MAP_H = 96;
const TILES = { GRASS:0, FOREST:1, ROCK:2, WATER:3, FERTILE:4, FARMLAND:5, SAND:6, SNOW:7 };
const ZONES = { NONE:0, FARM:1, CUT:2, MINE:4 };
const WALKABLE = new Set([TILES.GRASS, TILES.FOREST, TILES.ROCK, TILES.FERTILE, TILES.FARMLAND, TILES.SAND, TILES.SNOW]);
const ITEM = { FOOD:'food', WOOD:'wood', STONE:'stone' };
const DIR4 = [[1,0],[-1,0],[0,1],[0,-1]];
const SPEEDS = [0.5, 1, 2, 4];

/* ==================== Canvas & Camera ==================== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });
let DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
let W=0, H=0;
let cam = { x:0, y:0, z:2.2 }; // x,y in device pixels; draw scales by z
const MIN_Z=1.2, MAX_Z=4.5;

function resize(){
  DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  W = Math.floor(window.innerWidth * DPR);
  H = Math.floor(window.innerHeight * DPR);
  canvas.width = W; canvas.height = H;
  canvas.style.width = '100vw'; canvas.style.height = '100vh';
}
resize(); window.addEventListener('resize', resize);
function clampCam(){
  const maxX = MAP_W*TILE*cam.z - W;
  const maxY = MAP_H*TILE*cam.z - H;
  cam.x = Math.max(0, Math.min(cam.x, Math.max(0,maxX)));
  cam.y = Math.max(0, Math.min(cam.y, Math.max(0,maxY)));
}

/* ==================== RNG ==================== */
function mulberry32(seed) { return function(){ let t=seed+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
let R = Math.random;
const irnd=(a,b)=> (R()*(b-a+1)|0)+a;
const rnd=(a,b)=> R()*(b-a)+a;
const clamp=(v,mi,ma)=>v<mi?mi:(v>ma?ma:v);

/* ==================== Tileset (pixel art generated in code) ==================== */
const Tileset = { base:{}, waterOverlay:[], zoneGlyphs:{}, villagerSprites:{} };
function makeCanvas(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }
function px(g,x,y,c){ g.fillStyle=c; g.fillRect(x,y,1,1); }
function rect(g,x,y,w,h,c){ g.fillStyle=c; g.fillRect(x,y,w,h); }

function makeGrass(){ const c=makeCanvas(TILE,TILE), g=c.getContext('2d'); rect(g,0,0,TILE,TILE,'#245a2f'); for(let i=0;i<40;i++){ px(g,irnd(0,TILE-1),irnd(0,TILE-1), (i%3===0)?'#2f7d3d':(i%2===0?'#2a6b37':'#2a5f34')); } g.globalAlpha=0.25; rect(g,0,TILE-5,TILE,5,'#1a3e22'); g.globalAlpha=1; return c; }
function makeFertile(){ const c=makeCanvas(TILE,TILE), g=c.getContext('2d'); rect(g,0,0,TILE,TILE,'#3c2a1e'); g.globalAlpha=0.2; for(let y=4;y<TILE;y+=6){ rect(g,0,y,TILE,2,'#2a1d15'); } g.globalAlpha=1; return c; }
function makeSand(){ const c=makeCanvas(TILE,TILE), g=c.getContext('2d'); rect(g,0,0,TILE,TILE,'#b99a52'); for(let i=0;i<28;i++){ px(g,irnd(0,TILE-1),irnd(0,TILE-1), i%2?'#c7ad69':'#a78848'); } return c; }
function makeSnow(){ const c=makeCanvas(TILE,TILE), g=c.getContext('2d'); rect(g,0,0,TILE,TILE,'#d7e6f8'); for(let i=0;i<24;i++){ px(g,irnd(0,TILE-1),irnd(0,TILE-1), '#c9d7ea'); } rect(g,0,TILE-4,TILE,4,'#c0d0e8'); return c; }
function makeRock(){ const c=makeCanvas(TILE,TILE), g=c.getContext('2d'); rect(g,0,0,TILE,TILE,'#59616c'); for(let i=0;i<30;i++){ px(g,irnd(0,TILE-1),irnd(0,TILE-1), i%2?'#8f99a5':'#6c757f'); } rect(g,0,TILE-5,TILE,5,'#4a525b'); return c; }
function makeWaterBase(){ const c=makeCanvas(TILE,TILE), g=c.getContext('2d'); rect(g,0,0,TILE,TILE,'#134a6a'); for(let i=0;i<14;i'){ px(g,irnd(0,TILE-1),irnd(0,TILE-1), i%2?'#0f3e59':'#0c3248'); } return c; }
function makeWaterOverlayFrames(){ const frames=[]; for(let f=0; f<3; f++){ const c=makeCanvas(TILE,TILE), g=c.getContext('2d'); g.globalAlpha=0.22; g.strokeStyle='#4fa3d6'; g.lineWidth=1; g.beginPath(); for(let i=0;i<3;i++){ const y=6+i*10+f*2; g.moveTo(0,y); g.quadraticCurveTo(TILE*0.5,y+2,TILE,y); } g.stroke(); g.globalAlpha=1; frames.push(c); } return frames; }
function makeFarmland(){ const c=makeCanvas(TILE,TILE), g=c.getContext('2d'); rect(g,0,0,TILE,TILE,'#4a3624'); g.globalAlpha=0.25; for(let y=3;y<TILE;y+=6){ rect(g,0,y,TILE,2,'#3b2a1d'); } g.globalAlpha=1; return c; }
function drawSproutOn(g,stage){ const s=Math.min(3,Math.floor(stage)); if(s<=0) return; const gx=8, gy=10; g.fillStyle='#86c06c'; g.fillRect(gx,gy,2,2); if(s>=2){ g.fillRect(gx-2,gy+2,6,2); } if(s>=3){ g.fillRect(gx-1,gy-2,4,2); } }
function makeZoneGlyphs(){ const farm=makeCanvas(8,8), f=farm.getContext('2d'); rect(f,0,0,8,8,'rgba(0,0,0,0)'); px(f,3,6,'#9dd47a'); px(f,4,6,'#9dd47a'); px(f,3,5,'#73b85d'); px(f,4,5,'#73b85d'); px(f,3,4,'#5aa34b'); const cut=makeCanvas(8,8), c=cut.getContext('2d'); rect(c,0,0,8,8,'rgba(0,0,0,0)'); rect(c,2,2,4,1,'#caa56a'); rect(c,3,1,2,1,'#8f6934'); const mine=makeCanvas(8,8), m=mine.getContext('2d'); rect(m,0,0,8,8,'rgba(0,0,0,0)'); rect(m,2,2,4,1,'#9aa3ad'); rect(m,3,3,2,1,'#6d7782'); Tileset.zoneGlyphs={farm,cut,mine}; }
function makeVillagerFrames(){ function role(shirt,hat){ const frames=[]; for(let f=0; f<3; f++){ const c=makeCanvas(16,16), g=c.getContext('2d'); rect(g,7,4,2,2,'#f1d4b6'); if(hat){ rect(g,6,3,4,1,hat); rect(g,6,2,4,1,hat); } rect(g,6,6,4,4,shirt); if(f===0){ rect(g,5,6,1,3,shirt); rect(g,10,6,1,2,shirt); } if(f===1){ rect(g,5,6,1,2,shirt); rect(g,10,6,1,3,shirt); } if(f===2){ rect(g,5,6,1,2,shirt); rect(g,10,6,1,2,shirt); } rect(g,6,10,1,4,'#3f3f4f'); rect(g,9,10,1,4,'#3f3f4f'); frames.push(c);} return frames; } Tileset.villagerSprites.farmer=role('#3aa357','#d6cf74'); Tileset.villagerSprites.worker=role('#a36b3a','#8f7440'); Tileset.villagerSprites.explorer=role('#3a6aa3',null); Tileset.villagerSprites.sleepy=role('#777','#444'); }
function buildTileset(){ Tileset.base.grass=makeGrass(); Tileset.base.fertile=makeFertile(); Tileset.base.sand=makeSand(); Tileset.base.snow=makeSnow(); Tileset.base.rock=makeRock(); Tileset.base.water=makeWaterBase(); Tileset.base.farmland=makeFarmland(); Tileset.waterOverlay=makeWaterOverlayFrames(); makeZoneGlyphs(); makeVillagerFrames(); }

/* ==================== World State ==================== */
let world=null, buildings=[], villagers=[], jobs=[], itemsOnGround=[], storageTotals={food:0,wood:0,stone:0};
let tick=0, paused=false, speedIdx=1, dayTime=0; const DAY_LEN=60*40;
const BUILDINGS = { campfire:{label:'Campfire',cost:0,wood:0,stone:0}, storage:{label:'Storage',cost:8,wood:8,stone:0}, hut:{label:'Hut',cost:10,wood:10,stone:0}, farmplot:{label:'Farm Plot',cost:4,wood:4,stone:0}, well:{label:'Well',cost:6,wood:0,stone:6} };

function newWorld(seed=Date.now()|0){
  R = mulberry32(seed>>>0);
  jobs.length=0; buildings.length=0; itemsOnGround.length=0;
  storageTotals={food:8, wood:12, stone:0};
  tick=0; dayTime=0;
  world={ seed, tiles:new Uint8Array(MAP_W*MAP_H), zone:new Uint8Array(MAP_W*MAP_H), trees:new Uint8Array(MAP_W*MAP_H), rocks:new Uint8Array(MAP_W*MAP_H), berries:new Uint8Array(MAP_W*MAP_H), growth:new Uint8Array(MAP_W*MAP_H), season:0, tSeason:0 };
  function idc(x,y){ return y*MAP_W+x; }
  for(let y=0;y<MAP_H;y++){ for(let x=0;x<MAP_W;x++){ const v=R(); let t=TILES.GRASS;
    if(v<0.10) t=TILES.WATER; else if(v<0.18) t=TILES.ROCK; else if(v<0.52) t=TILES.FOREST; else if(v<0.72) t=TILES.FERTILE; else if(v<0.80) t=TILES.SAND; else if(v<0.86) t=TILES.SNOW;
    world.tiles[idc(x,y)]=t; world.zone[idc(x,y)]=0; world.growth[idc(x,y)]=0;
    if(t===TILES.FOREST && R()<0.9) world.trees[idc(x,y)]=1+(R()<0.6?1:0);
    if(t===TILES.ROCK && R()<0.7) world.rocks[idc(x,y)]=1+(R()<0.5?1:0);
    if((t===TILES.GRASS||t===TILES.FERTILE) && R()<0.14) world.berries[idc(x,y)]=1;
  } }
  let sx=MAP_W>>1, sy=MAP_H>>1;
  for(let k=0;k<200;k++){ const x=(MAP_W>>1)+irnd(-8,8), y=(MAP_H>>1)+irnd(-8,8); const t=world.tiles[idc(x,y)]; if(t!==TILES.WATER && t!==TILES.ROCK){ sx=x; sy=y; break; } }
  addBuilding('campfire',sx,sy,{built:1}); addBuilding('storage',sx+1,sy,{built:1});
  villagers.length=0; for(let i=0;i<6;i++){ villagers.push(newVillager(sx+irnd(-1,1), sy+irnd(-1,1))); }
  toast('New pixel map created.'); centerCamera(sx,sy); markStaticDirty();
}
function newVillager(x,y){ const r=R(); let role=r<0.25?'farmer':r<0.5?'worker':r<0.75?'explorer':'sleepy'; return { id:crypto.getRandomValues(new Uint32Array(1))[0]>>>0, x,y,path:[], hunger:rnd(0.2,0.5), energy:rnd(0.5,0.9), happy:rnd(0.4,0.8), speed:2+rnd(-0.2,0.2), inv:null, state:'idle', thought:'Wandering', role }; }
function addBuilding(kind,x,y,opts={}){ const def=BUILDINGS[kind]; const b={ id:crypto.getRandomValues(new Uint32Array(1))[0]>>>0, kind,x,y, built:opts.built?1:0, progress:opts.built?def.cost:0, store:(kind==='storage'?{wood:0,stone:0,food:0}:null) }; buildings.push(b); return b; }

/* ==================== UI & Sheets ==================== */
const el=(id)=>document.getElementById(id);
function toast(msg,ms=1500){ const t=el('toast'); t.textContent=msg; t.setAttribute('data-show','true'); clearTimeout(toast._t); toast._t=setTimeout(()=>t.removeAttribute('data-show'),ms); }
let ui={ mode:'inspect', zonePaint:ZONES.FARM, buildKind:null, brush:2 };
el('chipInspect').addEventListener('click', ()=> openMode('inspect'));
el('chipZones').addEventListener('click', ()=> { openMode('zones'); sheetZones(true); });
el('chipBuild').addEventListener('click', ()=> { openMode('build'); sheetBuild(true); });
el('chipPrior').addEventListener('click', ()=> { openMode('prior'); sheetPrior(true); });
el('btnPause').addEventListener('click', ()=> { paused=!paused; el('btnPause').textContent=paused?'‚ñ∂Ô∏è':'‚è∏'; });
el('btnSpeed').addEventListener('click', ()=> { speedIdx=(speedIdx+1)%SPEEDS.length; el('btnSpeed').textContent=SPEEDS[speedIdx]+'√ó'; });
el('btnSave').addEventListener('click', ()=> { saveGame(); toast('Saved.'); });
el('btnNew').addEventListener('click', ()=> { newWorld(); });
el('btnHelpClose').addEventListener('click', ()=> { el('help').style.display='none'; localStorage.setItem('aiv_help_px3','1'); });
function sheetZones(o){ document.getElementById('sheetZones').setAttribute('data-open',o?'true':'false'); }
function sheetBuild(o){ document.getElementById('sheetBuild').setAttribute('data-open',o?'true':'false'); }
function sheetPrior(o){ document.getElementById('sheetPrior').setAttribute('data-open',o?'true':'false'); }
function openMode(m){ ui.mode=m; document.querySelectorAll('.chip').forEach(n=>n.removeAttribute('data-active')); el('chip'+m.charAt(0).toUpperCase()+m.slice(1)).setAttribute('data-active','true'); if(m!=='zones') sheetZones(false); if(m!=='build') sheetBuild(false); if(m!=='prior') sheetPrior(false); }

/* ==================== Pan/Pinch ==================== */
let drag={active:false,sx:0,sy:0,camx:0,camy:0};
let pinch={active:false,startDist:0,startZ:0,midx:0,midy:0};

function screenToWorld(px,py){ return { x: ((px*DPR) - cam.x) / (TILE*cam.z), y: ((py*DPR) - cam.y) / (TILE*cam.z) }; }

canvas.addEventListener('mousedown', (e)=>{
  drag.active=true; drag.sx=e.clientX; drag.sy=e.clientY; drag.camx=cam.x; drag.camy=cam.y;
  if(ui.mode==='build'){ const w=screenToWorld(e.clientX,e.clientY); placeBlueprint(ui.buildKind||'hut', w.x|0, w.y|0); }
  if(ui.mode==='zones'){ const w=screenToWorld(e.clientX,e.clientY); paintZoneAt(w.x|0,w.y|0); }
});
canvas.addEventListener('mousemove', (e)=>{
  if(drag.active && ui.mode!=='zones'){ const dx=(e.clientX-drag.sx)*DPR, dy=(e.clientY-drag.sy)*DPR; cam.x=drag.camx - dx; cam.y=drag.camy - dy; clampCam(); }
  else if(ui.mode==='zones' && drag.active){ const w=screenToWorld(e.clientX,e.clientY); paintZoneAt(w.x|0,w.y|0); }
});
canvas.addEventListener('mouseup', ()=> drag.active=false);
canvas.addEventListener('mouseleave', ()=> drag.active=false);

canvas.addEventListener('wheel', (e)=>{
  const delta=Math.sign(e.deltaY); const scale=delta>0?1/1.1:1.1; const mx=e.clientX,my=e.clientY;
  const before=screenToWorld(mx,my); cam.z=clamp(cam.z*scale, MIN_Z, MAX_Z); const after=screenToWorld(mx,my);
  cam.x += (after.x-before.x)*(TILE*cam.z); cam.y += (after.y-before.y)*(TILE*cam.z); clampCam();
});

canvas.addEventListener('touchstart', (e)=>{
  if(e.touches.length===1){
    const t=e.touches[0]; drag.active=true; drag.sx=t.clientX; drag.sy=t.clientY; drag.camx=cam.x; drag.camy=cam.y;
    if(ui.mode==='build'){ const w=screenToWorld(t.clientX,t.clientY); placeBlueprint(ui.buildKind||'hut', w.x|0, w.y|0); }
    if(ui.mode==='zones'){ const w=screenToWorld(t.clientX,t.clientY); paintZoneAt(w.x|0,w.y|0); }
  } else if(e.touches.length===2){
    pinch.active=true; const t0=e.touches[0], t1=e.touches[1]; pinch.startDist=Math.hypot(t1.clientX-t0.clientX,t1.clientY-t0.clientY); pinch.startZ=cam.z; pinch.midx=(t0.clientX+t1.clientX)/2; pinch.midy=(t0.clientY+t1.clientY)/2;
  }
  e.preventDefault();
},{passive:false});
canvas.addEventListener('touchmove', (e)=>{
  if(pinch.active && e.touches.length===2){
    const t0=e.touches[0], t1=e.touches[1]; const dist=Math.hypot(t1.clientX-t0.clientX,t1.clientY-t0.clientY);
    const before=screenToWorld(pinch.midx,pinch.midy); cam.z=clamp((dist/(pinch.startDist||1))*pinch.startZ, MIN_Z, MAX_Z); const after=screenToWorld(pinch.midx,pinch.midy);
    cam.x += (after.x-before.x)*(TILE*cam.z); cam.y += (after.y-before.y)*(TILE*cam.z);
    const midx=(t0.clientX+t1.clientX)/2, midy=(t0.clientY+t1.clientY)/2; cam.x -= (midx-pinch.midx)*DPR; cam.y -= (midy-pinch.midy)*DPR; pinch.midx=midx; pinch.midy=midy; clampCam();
  } else if(drag.active){
    const t=e.touches[0];
    if(ui.mode!=='zones'){ const dx=(t.clientX-drag.sx)*DPR, dy=(t.clientY-drag.sy)*DPR; cam.x=drag.camx - dx; cam.y=drag.camy - dy; clampCam(); }
    else { const w=screenToWorld(t.clientX,t.clientY); paintZoneAt(w.x|0,w.y|0); }
  }
  e.preventDefault();
},{passive:false});
canvas.addEventListener('touchend', (e)=>{ if(e.touches.length<2) pinch.active=false; if(e.touches.length===0) drag.active=false; e.preventDefault(); },{passive:false});

/* ==================== Zones/Build/Helpers ==================== */
document.getElementById('sheetZones').addEventListener('click', (e)=>{ const t=e.target.closest('.tile'); if(!t) return; const z=t.getAttribute('data-zone'); ui.zonePaint=z==='farm'?ZONES.FARM:z==='cut'?ZONES.CUT:z==='mine'?ZONES.MINE:ZONES.NONE; toast('Zone: '+(z==='erase'?'Clear':z.toUpperCase())); });
document.getElementById('brushSize').addEventListener('input', (e)=> ui.brush=parseInt(e.target.value||'2'));
document.getElementById('sheetBuild').addEventListener('click', (e)=>{ const t=e.target.closest('.tile'); if(!t) return; ui.buildKind=t.getAttribute('data-build'); toast('Tap map to place: '+ui.buildKind); });
const priorities={ food:0.7, build:0.5, explore:0.3 };
document.getElementById('prioFood').addEventListener('input', e=> priorities.food=(parseInt(e.target.value,10)||0)/100 );
document.getElementById('prioBuild').addEventListener('input', e=> priorities.build=(parseInt(e.target.value,10)||0)/100 );
document.getElementById('prioExplore').addEventListener('input', e=> priorities.explore=(parseInt(e.target.value,10)||0)/100 );
function idx(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return -1; return y*MAP_W+x; }
function getTile(x,y){ const i=idx(x,y); if(i<0) return null; return { t:world.tiles[i], i }; }
function centerCamera(x,y){ cam.z=2.2; cam.x=x*TILE*cam.z - W*0.5; cam.y=y*TILE*cam.z - H*0.5; clampCam(); }
function paintZoneAt(cx,cy){ if(cx<0||cy<0||cx>=MAP_W||cy>=MAP_H) return; const r=ui.brush|0; for(let y=cy-r;y<=cy+r;y++){ for(let x=cx-r;x<=cx+r;x++){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) continue; world.zone[y*MAP_W+x]=ui.zonePaint; } } }
function placeBlueprint(kind,x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return; const t=getTile(x,y); if(!t||t.t===TILES.WATER){ toast('Cannot build on water.'); return; } if(buildings.some(b=>b.x===x&&b.y===y)){ toast('Tile occupied.'); return; } addBuilding(kind,x,y,{built:0}); toast('Blueprint placed.'); }

/* ==================== Jobs & AI (trimmed to essentials) ==================== */
function addJob(job){ job.id=crypto.getRandomValues(new Uint32Array(1))[0]>>>0; job.assigned=0; jobs.push(job); return job; }
function generateJobs(){ for(let y=0;y<MAP_H;y++){ for(let x=0;x<MAP_W;x++){ const i=y*MAP_W+x; const z=world.zone[i];
  if(z===ZONES.FARM){ if(world.tiles[i]!==TILES.WATER && !jobs.some(j=>j.type==='sow'&&j.x===x&&j.y===y)) addJob({type:'sow',x,y, prio:0.6+priorities.food*0.6}); }
  else if(z===ZONES.CUT){ if(world.trees[i]>0 && !jobs.some(j=>j.type==='chop'&&j.x===x&&j.y===y)) addJob({type:'chop',x,y, prio:0.5+priorities.build*0.5}); }
  else if(z===ZONES.MINE){ if(world.rocks[i]>0 && !jobs.some(j=>j.type==='mine'&&j.x===x&&j.y===y)) addJob({type:'mine',x,y, prio:0.5+priorities.build*0.5}); }
} } buildings.forEach(b=>{ if(b.built<1 && !jobs.some(j=>j.type==='build'&&j.bid===b.id)) addJob({type:'build',bid:b.id,x:b.x,y:b.y,prio:0.6+priorities.build*0.6}); }); }
function villagerTick(v){
  v.hunger += 0.0015; v.energy -= 0.0012; v.happy += nearbyWarmth(v.x|0,v.y|0)?0.0008:-0.0004;
  v.hunger=clamp(v.hunger,0,1.2); v.energy=clamp(v.energy,0,1); v.happy=clamp(v.happy,0,1);
  if(v.hunger>0.9){ if(consumeFood(v)){ v.thought='Eating'; return; } if(foragingJob(v)) return; }
  if(v.energy<0.15){ if(goRest(v)) return; }
  if(v.path && v.path.length>0){ stepAlong(v); return; }
  if(v.inv){ const s=findNearestBuilding(v.x|0,v.y|0,'storage'); if(s){ const p=pathfind(v.x|0,v.y|0,s.x,s.y); if(p){ v.path=p; v.state='to_storage'; v.thought='Storing'; return; } } }
  const j=pickJobFor(v); if(j){ const dest={x:j.x,y:j.y}; if(j.type==='build'){ const b=buildings.find(bb=>bb.id===j.bid); if(b) dest.x=b.x, dest.y=b.y; } const p=pathfind(v.x|0,v.y|0,dest.x,dest.y); if(p){ v.path=p; v.state=j.type; v.targetJob=j; v.thought=j.type.toUpperCase(); j.assigned++; return; } }
  v.thought='Wandering'; const nx=clamp((v.x|0)+irnd(-4,4),0,MAP_W-1), ny=clamp((v.y|0)+irnd(-4,4),0,MAP_H-1); const p=pathfind(v.x|0,v.y|0,nx,ny,60); if(p) v.path=p;
}
function nearbyWarmth(x,y){ return buildings.some(b=>b.kind==='campfire' && Math.abs(b.x-x)+Math.abs(b.y-y)<=2); }
function consumeFood(v){ if(v.inv&&v.inv.type===ITEM.FOOD){ v.hunger-=0.6; if(v.hunger<0)v.hunger=0; v.inv=null; return true; } if(storageTotals.food>0){ storageTotals.food--; v.hunger-=0.6; if(v.hunger<0)v.hunger=0; return true; } return false; }
function foragingJob(v){ const r=10,sx=v.x|0,sy=v.y|0; let best=null,bd=999; for(let y=sy-r;y<=sy+r;y++){ for(let x=sx-r;x<=sx+r;x++){ const i=idx(x,y); if(i<0) continue; if(world.berries[i]>0){ const d=Math.abs(x-sx)+Math.abs(y-sy); if(d<bd){bd=d; best={x,y,i};} } } } if(best){ const p=pathfind(v.x|0,v.y|0,best.x,best.y,120); if(p){ v.path=p; v.state='forage'; v.targetI=best.i; v.thought='Foraging'; return true; } } return false; }
function goRest(v){ const hut=findNearestBuilding(v.x|0,v.y|0,'hut')||buildings.find(b=>b.kind==='campfire'); if(hut){ const p=pathfind(v.x|0,v.y|0,hut.x,hut.y); if(p){ v.path=p; v.state='rest'; v.targetBuilding=hut; v.thought='Resting'; return true; } } return false; }
function findNearestBuilding(x,y,kind){ let best=null,bd=999; for(const b of buildings){ if(b.kind!==kind||b.built<1) continue; const d=Math.abs(b.x-x)+Math.abs(b.y-y); if(d<bd){bd=d; best=b;} } return best; }
function pickJobFor(v){ let best=null,bs=-1e9; for(const j of jobs){ if(j.assigned>=1 && j.type!=='build') continue; const i=idx(j.x,j.y); if(j.type==='chop'&&world.trees[i]===0) continue; if(j.type==='mine'&&world.rocks[i]===0) continue; if(j.type==='sow'&&world.tiles[i]===TILES.FARMLAND) continue; const d=Math.abs((v.x|0)-j.x)+Math.abs((v.y|0)-j.y); let s=(j.prio||0.5)-d*0.01; if(v.role==='farmer'&&(j.type==='sow'||j.type==='harvest')) s+=0.08; if(v.role==='worker'&&(j.type==='chop'||j.type==='mine'||j.type==='build')) s+=0.06; if(v.hunger>0.6&&(j.type==='sow'||j.type==='harvest')) s+=0.03; if(s>bs){ bs=s; best=j; } } return bs>0?best:null; }
function stepAlong(v){ const next=v.path[0]; if(!next) return; const speed=v.speed*SPEEDS[speedIdx]; const dx=next.x-v.x, dy=next.y-v.y, dist=Math.hypot(dx,dy), step=0.08*speed; if(dist<=step){ v.x=next.x; v.y=next.y; v.path.shift(); if(v.path.length===0) onArrive(v); } else { v.x+=(dx/dist)*step; v.y+=(dy/dist)*step; } }
function onArrive(v){ const cx=v.x|0, cy=v.y|0, i=idx(cx,cy); if(v.state==='chop'){ if(world.trees[i]>0){ world.trees[i]--; dropItem(cx,cy,ITEM.WOOD,1); if(world.trees[i]===0){ world.tiles[i]=TILES.GRASS; markStaticDirty(); } v.thought='Chopped'; } v.state='idle'; v.targetJob=null; }
else if(v.state==='mine'){ if(world.rocks[i]>0){ world.rocks[i]--; dropItem(cx,cy,ITEM.STONE,1); if(world.rocks[i]===0){ world.tiles[i]=TILES.GRASS; markStaticDirty(); } v.thought='Mined'; } v.state='idle'; v.targetJob=null; }
else if(v.state==='forage'){ if(world.berries[v.targetI]>0){ world.berries[v.targetI]--; v.inv={type:ITEM.FOOD,qty:1}; v.thought='Got berries'; } v.state='idle'; }
else if(v.state==='sow'){ if(world.tiles[i]!==TILES.WATER){ world.tiles[i]=TILES.FARMLAND; world.growth[i]=1; world.zone[i]=ZONES.FARM; markStaticDirty(); v.thought='Sowed'; } v.state='idle'; v.targetJob=null; }
else if(v.state==='harvest'){ dropItem(cx,cy,ITEM.FOOD,1); world.growth[i]=0; v.state='idle'; v.thought='Harvested'; }
else if(v.state==='build'){ const b=buildings.find(bb=>bb.id===v.targetJob?.bid); if(b){ const def=BUILDINGS[b.kind]; if(b.built<1){ const need=def.cost-(b.progress||0); let pulled=0; if(def.wood>0){ const take=Math.min(need,storageTotals.wood); storageTotals.wood-=take; pulled+=take; } if(def.stone>0){ const take=Math.min(need-pulled,storageTotals.stone); storageTotals.stone-=take; pulled+=take; } b.progress=(b.progress||0)+pulled; if(b.progress>=def.cost){ b.built=1; v.thought='Built'; } } } v.state='idle'; v.targetJob=null; }
else if(v.state==='to_storage'){ if(v.inv){ if(v.inv.type===ITEM.WOOD) storageTotals.wood+=v.inv.qty; if(v.inv.type===ITEM.STONE) storageTotals.stone+=v.inv.qty; if(v.inv.type===ITEM.FOOD) storageTotals.food+=v.inv.qty; v.inv=null; v.thought='Stored'; } v.state='idle'; }
else if(v.state==='rest'){ v.energy += 0.4; if(v.energy>1)v.energy=1; v.thought='Rested'; v.state='idle'; } }

/* ==================== Pathfinding ==================== */
function passable(x,y){ const i=idx(x,y); if(i<0) return false; return WALKABLE.has(world.tiles[i]); }
function pathfind(sx,sy,tx,ty,limit=400){ if(sx===tx&&sy===ty) return [{x:tx,y:ty}]; const Wm=MAP_W,Hm=MAP_H,total=Wm*Hm; const qx=new Int16Array(total), qy=new Int16Array(total); const came=new Int32Array(total); for(let k=0;k<total;k++) came[k]=-1; let qs=0,qe=0; qx[qe]=sx; qy[qe]=sy; qe++; came[sy*Wm+sx]=sx+sy*Wm; let found=false,steps=0; while(qs<qe && steps<limit){ const x=qx[qs], y=qy[qs]; qs++; steps++; for(const d of DIR4){ const nx=x+d[0], ny=y+d[1]; if(nx<0||ny<0||nx>=Wm||ny>=Hm) continue; const ni=ny*Wm+nx; if(came[ni]!==-1) continue; if(!passable(nx,ny)) continue; came[ni]=y*Wm+x; qx[qe]=nx; qy[qe]=ny; qe++; if(nx===tx&&ny===ty){ found=true; qs=qe; break; } } } if(!found) return null; const path=[]; let cx=tx,cy=ty,ci=cy*Wm+cx; while(!(cx===sx&&cy===sy)){ path.push({x:cx+0.0001,y:cy+0.0001}); const pi=came[ci]; cy=(pi/Wm)|0; cx=pi%Wm; ci=cy*Wm+cx; } path.reverse(); return path; }

/* ==================== Seasons/Growth ==================== */
function seasonTick(){ world.tSeason++; const SEASON_LEN=60*10; if(world.tSeason>=SEASON_LEN){ world.tSeason=0; world.season=(world.season+1)%4; } for(let i=0;i<world.growth.length;i++){ if(world.tiles[i]===TILES.FARMLAND && world.growth[i]>0 && world.growth[i]<240){ world.growth[i]+=1; if(world.growth[i]===160){ const y=(i/MAP_W)|0, x=i%MAP_W; if(!jobs.some(j=>j.type==='harvest'&&j.x===x&&j.y===y)) addJob({type:'harvest',x,y, prio:0.65+priorities.food*0.6}); } } } }

/* ==================== Save/Load ==================== */
function saveGame(){ const data={ seed:world.seed, tiles:Array.from(world.tiles), zone:Array.from(world.zone), trees:Array.from(world.trees), rocks:Array.from(world.rocks), berries:Array.from(world.berries), growth:Array.from(world.growth), season:world.season, tSeason:world.tSeason, buildings, storageTotals, villagers: villagers.map(v=>({id:v.id,x:v.x,y:v.y,h:v.hunger,e:v.energy,ha:v.happy,role:v.role})) }; localStorage.setItem('aiv_px_v3_save', JSON.stringify(data)); }
function loadGame(){ try{ const raw=localStorage.getItem('aiv_px_v3_save'); if(!raw) return false; const d=JSON.parse(raw); newWorld(d.seed); world.tiles=Uint8Array.from(d.tiles); world.zone=Uint8Array.from(d.zone); world.trees=Uint8Array.from(d.trees); world.rocks=Uint8Array.from(d.rocks); world.berries=Uint8Array.from(d.berries); world.growth=Uint8Array.from(d.growth); world.season=d.season; world.tSeason=d.tSeason; buildings.length=0; d.buildings.forEach(b=>buildings.push(b)); storageTotals=d.storageTotals; villagers.length=0; d.villagers.forEach(v=>{ villagers.push({ id:v.id,x:v.x,y:v.y,path:[], hunger:v.h,energy:v.e,happy:v.ha,role:v.role,speed:2,inv:null,state:'idle',thought:'Resuming' }); }); toast('Loaded.'); markStaticDirty(); return true; } catch(e){ console.error(e); return false; } }

/* ==================== Rendering ==================== */
let staticCanvas=null, staticCtx=null, staticDirty=true;
function markStaticDirty(){ staticDirty=true; }
function drawStatic(){ if(!staticCanvas){ staticCanvas=makeCanvas(MAP_W*TILE, MAP_H*TILE); staticCtx=staticCanvas.getContext('2d'); staticCtx.imageSmoothingEnabled=false; } const g=staticCtx;
  for(let y=0;y<MAP_H;y++){ for(let x=0;x<MAP_W;x++){ const i=y*MAP_W+x, t=world.tiles[i];
    let img=Tileset.base.grass; if(t===TILES.GRASS) img=Tileset.base.grass; else if(t===TILES.FERTILE) img=Tileset.base.fertile; else if(t===TILES.SAND) img=Tileset.base.sand; else if(t===TILES.SNOW) img=Tileset.base.snow; else if(t===TILES.ROCK) img=Tileset.base.rock; else if(t===TILES.WATER) img=Tileset.base.water; else if(t===TILES.FARMLAND) img=Tileset.base.farmland; g.drawImage(img,x*TILE,y*TILE);
  } } staticDirty=false; }

function drawTree(g){ g.fillStyle='#6b3f1f'; g.fillRect(14,20,4,6); g.fillStyle='#2c6b34'; g.fillRect(10,12,12,10); g.fillStyle='#2f7f3d'; g.fillRect(12,10,8,4); }
function drawBerry(g){ g.fillStyle='#2f6d36'; g.fillRect(8,16,16,10); g.fillStyle='#a04a5a'; g.fillRect(12,18,2,2); g.fillRect(18,20,2,2); g.fillRect(16,22,2,2); }

function render(){
  if(staticDirty) drawStatic();
  ctx.imageSmoothingEnabled=false; ctx.fillStyle='#0a0c10'; ctx.fillRect(0,0,W,H);
  // base map scaled by cam.z
  ctx.drawImage(staticCanvas, 0,0, staticCanvas.width, staticCanvas.height, -cam.x, -cam.y, staticCanvas.width*cam.z, staticCanvas.height*cam.z);

  // animated water overlay
  const frame=Math.floor((tick/10)%Tileset.waterOverlay.length);
  for(let y=0;y<MAP_H;y++){ for(let x=0;x<MAP_W;x++){ const i=y*MAP_W+x; if(world.tiles[i]===TILES.WATER){
    ctx.drawImage(Tileset.waterOverlay[frame], 0,0,TILE,TILE, -cam.x+x*TILE*cam.z, -cam.y+y*TILE*cam.z, TILE*cam.z, TILE*cam.z );
  } } }

  // zones glyphs
  ctx.globalAlpha=0.25;
  for(let y=0;y<MAP_H;y++){ for(let x=0;x<MAP_W;x++){ const i=y*MAP_W+x; const z=world.zone[i]; if(z===ZONES.NONE) continue; const glyph = z===ZONES.FARM ? Tileset.zoneGlyphs.farm : z===ZONES.CUT ? Tileset.zoneGlyphs.cut : Tileset.zoneGlyphs.mine;
    for(let yy=4; yy<TILE; yy+=10){ for(let xx=4; xx<TILE; xx+=10){
      ctx.drawImage(glyph, 0,0,8,8, -cam.x+x*TILE*cam.z+xx*cam.z, -cam.y+y*TILE*cam.z+yy*cam.z, 8*cam.z, 8*cam.z );
  } } } } ctx.globalAlpha=1;

  // vegetation/crops
  for(let y=0;y<MAP_H;y++){ for(let x=0;x<MAP_W;x++){ const i=y*MAP_W+x;
    if(world.tiles[i]===TILES.FOREST && world.trees[i]>0){ const cg=makeCanvas(TILE,TILE), g=cg.getContext('2d'); drawTree(g); ctx.drawImage(cg, 0,0,TILE,TILE, -cam.x+x*TILE*cam.z, -cam.y+y*TILE*cam.z, TILE*cam.z, TILE*cam.z ); }
    if(world.berries[i]>0){ const cg=makeCanvas(TILE,TILE), g=cg.getContext('2d'); drawBerry(g); ctx.drawImage(cg, 0,0,TILE,TILE, -cam.x+x*TILE*cam.z, -cam.y+y*TILE*cam.z, TILE*cam.z, TILE*cam.z ); }
    if(world.tiles[i]===TILES.FARMLAND && world.growth[i]>0){ const cg=makeCanvas(TILE,TILE), g=cg.getContext('2d'); drawSproutOn(g, world.growth[i]/60); ctx.drawImage(cg, 0,0,TILE,TILE, -cam.x+x*TILE*cam.z, -cam.y+y*TILE*cam.z, TILE*cam.z, TILE*cam.z ); }
  } }

  // buildings
  for(const b of buildings){ const gx=-cam.x + b.x*TILE*cam.z, gy=-cam.y + b.y*TILE*cam.z; drawBuildingAt(gx,gy,b); }

  // items
  for(const it of itemsOnGround){ const gx=-cam.x+it.x*TILE*cam.z, gy=-cam.y+it.y*TILE*cam.z; ctx.fillStyle = it.type===ITEM.WOOD ? '#b48a52' : it.type===ITEM.STONE ? '#aeb7c3' : '#b6d97a'; ctx.fillRect(gx+TILE*cam.z*0.5-2*cam.z, gy+TILE*cam.z*0.5-2*cam.z, 4*cam.z, 4*cam.z); }

  // villagers
  for(const v of villagers){ drawVillager(v); }

  // day/night tint (screen space)
  const t=dayTime/DAY_LEN; let night=(Math.cos((t*2*Math.PI))+1)/2; ctx.fillStyle=`rgba(10,18,30, ${0.25*night})`; ctx.fillRect(0,0,W,H);

  // campfire glow (screen space but positioned via cam)
  for(const b of buildings){ if(b.kind==='campfire'){ const gx=-cam.x+b.x*TILE*cam.z+TILE*cam.z/2, gy=-cam.y+b.y*TILE*cam.z+TILE*cam.z/2; const r= (24+4*Math.sin(tick*0.2))*cam.z; const grd=ctx.createRadialGradient(gx,gy,4*cam.z, gx,gy,r); grd.addColorStop(0,'rgba(255,180,90,0.35)'); grd.addColorStop(1,'rgba(255,120,60,0)'); ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(gx,gy,r,0,Math.PI*2); ctx.fill(); } }

  // HUD counters
  el('food').textContent=storageTotals.food|0; el('wood').textContent=storageTotals.wood|0; el('stone').textContent=storageTotals.stone|0; el('pop').textContent=villagers.length|0;
}

function drawBuildingAt(gx,gy,b){
  const g=ctx, s=cam.z;
  if(b.kind==='campfire'){ g.fillStyle='#7b8591'; g.fillRect(gx+10*s,gy+18*s,12*s,6*s); const f=(tick%6); g.fillStyle=['#ffde7a','#ffc05a','#ff9b4a'][f%3]; g.fillRect(gx+14*s,gy+12*s,4*s,6*s);
  } else if(b.kind==='storage'){ g.fillStyle='#6a5338'; g.fillRect(gx+6*s,gy+10*s,20*s,14*s); g.fillStyle='#8b6b44'; g.fillRect(gx+6*s,gy+20*s,20*s,2*s); g.fillStyle='#3b2b1a'; g.fillRect(gx+6*s,gy+10*s,20*s,1*s);
  } else if(b.kind==='hut'){ g.fillStyle='#7d5a3a'; g.fillRect(gx+8*s,gy+16*s,16*s,12*s); g.fillStyle='#caa56a'; g.fillRect(gx+6*s,gy+12*s,20*s,6*s); g.fillStyle='#31251a'; g.fillRect(gx+14*s,gy+20*s,4*s,8*s);
  } else if(b.kind==='farmplot'){ g.fillStyle='#4a3624'; g.fillRect(gx+4*s,gy+8*s,24*s,16*s); g.fillStyle='#3b2a1d'; g.fillRect(gx+4*s,gy+12*s,24*s,2*s); g.fillRect(gx+4*s,gy+16*s,24*s,2*s); g.fillRect(gx+4*s,gy+20*s,24*s,2*s);
  } else if(b.kind==='well'){ g.fillStyle='#6f8696'; g.fillRect(gx+10*s,gy+14*s,12*s,10*s); g.fillStyle='#2b3744'; g.fillRect(gx+12*s,gy+18*s,8*s,6*s); g.fillStyle='#927a54'; g.fillRect(gx+8*s,gy+12*s,16*s,2*s); }
  if(b.built<1){ g.strokeStyle='rgba(255,255,255,0.6)'; g.strokeRect(gx+4*s,gy+4*s,24*s,24*s); const p=(b.progress||0)/(BUILDINGS[b.kind].cost||1); g.fillStyle='#7cc4ff'; g.fillRect(gx+6*s,gy+28*s, Math.floor(20*p)*s, 2*s); }
}

function drawVillager(v){
  const frames = v.role==='farmer'? Tileset.villagerSprites.farmer : v.role==='worker'? Tileset.villagerSprites.worker : v.role==='explorer'? Tileset.villagerSprites.explorer : Tileset.villagerSprites.sleepy;
  const f=frames[Math.floor((tick/8)%3)], s=cam.z;
  const gx=-cam.x+v.x*TILE*cam.z + 8*s, gy=-cam.y+v.y*TILE*cam.z + 8*s;
  ctx.drawImage(f, 0,0,16,16, gx, gy, 16*s, 16*s);
  if(v.inv){ ctx.fillStyle=v.inv.type===ITEM.WOOD?'#b48a52':v.inv.type===ITEM.STONE?'#aeb7c3':'#b6d97a'; ctx.fillRect(gx+12*s, gy+2*s, 3*s, 3*s); }
}

/* ==================== Items & Loop ==================== */
function dropItem(x,y,type,qty){ itemsOnGround.push({x,y,type,qty}); }
let last=performance.now(), acc=0; const TICK_MS=1000/6;
function update(){ if(paused){ render(); requestAnimationFrame(update); return; } const now=performance.now(); let dt=now-last; last=now; dt*=SPEEDS[speedIdx]; acc+=dt; const steps=Math.floor(acc/TICK_MS); if(steps>0) acc-=steps*TICK_MS; for(let s=0;s<steps;s++){ tick++; dayTime=(dayTime+1)%DAY_LEN; if(tick%20===0) generateJobs(); if(tick%10===0) seasonTick(); for(const v of villagers){ if(!v.inv){ for(let k=0;k<itemsOnGround.length;k++){ const it=itemsOnGround[k]; if((v.x|0)===it.x && (v.y|0)===it.y){ v.inv={type:it.type,qty:it.qty}; itemsOnGround.splice(k,1); k--; break; } } } } for(const v of villagers){ villagerTick(v); } } render(); requestAnimationFrame(update); }

/* ==================== Boot ==================== */
function boot(){ buildTileset(); if(!loadGame()){ newWorld(); } openMode('inspect'); if(!localStorage.getItem('aiv_help_px3')) el('help').style.display='block'; requestAnimationFrame(update); }
boot();

})();</script>
</body>
</html>
